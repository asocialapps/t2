try{self["workbox:core:7.2.0"]&&_()}catch{}const q=(i,...e)=>{let t=i;return e.length>0&&(t+=` :: ${JSON.stringify(e)}`),t},z=q;class u extends Error{constructor(e,t){const s=z(e,t);super(s),this.name=e,this.details=t}}const V=new Set,f={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration<"u"?registration.scope:""},L=i=>[f.prefix,i,f.suffix].filter(e=>e&&e.length>0).join("-"),Y=i=>{for(const e of Object.keys(f))i(e)},k={updateDetails:i=>{Y(e=>{typeof i[e]=="string"&&(f[e]=i[e])})},getGoogleAnalyticsName:i=>i||L(f.googleAnalytics),getPrecacheName:i=>i||L(f.precache),getPrefix:()=>f.prefix,getRuntimeName:i=>i||L(f.runtime),getSuffix:()=>f.suffix};function B(i,e){const t=new URL(i);for(const s of e)t.searchParams.delete(s);return t.href}async function X(i,e,t,s){const n=B(e.url,t);if(e.url===n)return i.match(e,s);const r=Object.assign(Object.assign({},s),{ignoreSearch:!0}),a=await i.keys(e,r);for(const o of a){const c=B(o.url,t);if(n===c)return i.match(o,s)}}let y;function G(){if(y===void 0){const i=new Response("");if("body"in i)try{new Response(i.body),y=!0}catch{y=!1}y=!1}return y}class J{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}async function Q(){for(const i of V)await i()}const Z=i=>new URL(String(i),location.href).href.replace(new RegExp(`^${location.origin}`),"");function ee(i){return new Promise(e=>setTimeout(e,i))}function D(i,e){const t=e();return i.waitUntil(t),t}async function te(i,e){let t=null;if(i.url&&(t=new URL(i.url).origin),t!==self.location.origin)throw new u("cross-origin-copy-response",{origin:t});const s=i.clone(),r={headers:new Headers(s.headers),status:s.status,statusText:s.statusText},a=G()?s.body:await s.blob();return new Response(a,r)}function se(){self.addEventListener("activate",()=>self.clients.claim())}try{self["workbox:precaching:7.2.0"]&&_()}catch{}const ne="__WB_REVISION__";function ie(i){if(!i)throw new u("add-to-cache-list-unexpected-type",{entry:i});if(typeof i=="string"){const r=new URL(i,location.href);return{cacheKey:r.href,url:r.href}}const{revision:e,url:t}=i;if(!t)throw new u("add-to-cache-list-unexpected-type",{entry:i});if(!e){const r=new URL(t,location.href);return{cacheKey:r.href,url:r.href}}const s=new URL(t,location.href),n=new URL(t,location.href);return s.searchParams.set(ne,e),{cacheKey:s.href,url:n.href}}class re{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:e,state:t})=>{t&&(t.originalRequest=e)},this.cachedResponseWillBeUsed=async({event:e,state:t,cachedResponse:s})=>{if(e.type==="install"&&t&&t.originalRequest&&t.originalRequest instanceof Request){const n=t.originalRequest.url;s?this.notUpdatedURLs.push(n):this.updatedURLs.push(n)}return s}}}class ae{constructor({precacheController:e}){this.cacheKeyWillBeUsed=async({request:t,params:s})=>{const n=s?.cacheKey||this._precacheController.getCacheKeyForURL(t.url);return n?new Request(n,{headers:t.headers}):t},this._precacheController=e}}try{self["workbox:strategies:7.2.0"]&&_()}catch{}function C(i){return typeof i=="string"?new Request(i):i}class oe{constructor(e,t){this._cacheKeys={},Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new J,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const s of this._plugins)this._pluginStateMap.set(s,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){const{event:t}=this;let s=C(e);if(s.mode==="navigate"&&t instanceof FetchEvent&&t.preloadResponse){const a=await t.preloadResponse;if(a)return a}const n=this.hasCallback("fetchDidFail")?s.clone():null;try{for(const a of this.iterateCallbacks("requestWillFetch"))s=await a({request:s.clone(),event:t})}catch(a){if(a instanceof Error)throw new u("plugin-error-request-will-fetch",{thrownErrorMessage:a.message})}const r=s.clone();try{let a;a=await fetch(s,s.mode==="navigate"?void 0:this._strategy.fetchOptions);for(const o of this.iterateCallbacks("fetchDidSucceed"))a=await o({event:t,request:r,response:a});return a}catch(a){throw n&&await this.runCallbacks("fetchDidFail",{error:a,event:t,originalRequest:n.clone(),request:r.clone()}),a}}async fetchAndCachePut(e){const t=await this.fetch(e),s=t.clone();return this.waitUntil(this.cachePut(e,s)),t}async cacheMatch(e){const t=C(e);let s;const{cacheName:n,matchOptions:r}=this._strategy,a=await this.getCacheKey(t,"read"),o=Object.assign(Object.assign({},r),{cacheName:n});s=await caches.match(a,o);for(const c of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await c({cacheName:n,matchOptions:r,cachedResponse:s,request:a,event:this.event})||void 0;return s}async cachePut(e,t){const s=C(e);await ee(0);const n=await this.getCacheKey(s,"write");if(!t)throw new u("cache-put-with-no-response",{url:Z(n.url)});const r=await this._ensureResponseSafeToCache(t);if(!r)return!1;const{cacheName:a,matchOptions:o}=this._strategy,c=await self.caches.open(a),l=this.hasCallback("cacheDidUpdate"),p=l?await X(c,n.clone(),["__WB_REVISION__"],o):null;try{await c.put(n,l?r.clone():r)}catch(h){if(h instanceof Error)throw h.name==="QuotaExceededError"&&await Q(),h}for(const h of this.iterateCallbacks("cacheDidUpdate"))await h({cacheName:a,oldResponse:p,newResponse:r.clone(),request:n,event:this.event});return!0}async getCacheKey(e,t){const s=`${e.url} | ${t}`;if(!this._cacheKeys[s]){let n=e;for(const r of this.iterateCallbacks("cacheKeyWillBeUsed"))n=C(await r({mode:t,request:n,event:this.event,params:this.params}));this._cacheKeys[s]=n}return this._cacheKeys[s]}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(const s of this.iterateCallbacks(e))await s(t)}*iterateCallbacks(e){for(const t of this._strategy.plugins)if(typeof t[e]=="function"){const s=this._pluginStateMap.get(t);yield r=>{const a=Object.assign(Object.assign({},r),{state:s});return t[e](a)}}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let t=e,s=!1;for(const n of this.iterateCallbacks("cacheWillUpdate"))if(t=await n({request:this.request,response:t,event:this.event})||void 0,s=!0,!t)break;return s||t&&t.status!==200&&(t=void 0),t}}class ce{constructor(e={}){this.cacheName=k.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,s=typeof e.request=="string"?new Request(e.request):e.request,n="params"in e?e.params:void 0,r=new oe(this,{event:t,request:s,params:n}),a=this._getResponse(r,s,t),o=this._awaitComplete(a,r,s,t);return[a,o]}async _getResponse(e,t,s){await e.runCallbacks("handlerWillStart",{event:s,request:t});let n;try{if(n=await this._handle(t,e),!n||n.type==="error")throw new u("no-response",{url:t.url})}catch(r){if(r instanceof Error){for(const a of e.iterateCallbacks("handlerDidError"))if(n=await a({error:r,event:s,request:t}),n)break}if(!n)throw r}for(const r of e.iterateCallbacks("handlerWillRespond"))n=await r({event:s,request:t,response:n});return n}async _awaitComplete(e,t,s,n){let r,a;try{r=await e}catch{}try{await t.runCallbacks("handlerDidRespond",{event:n,request:s,response:r}),await t.doneWaiting()}catch(o){o instanceof Error&&(a=o)}if(await t.runCallbacks("handlerDidComplete",{event:n,request:s,response:r,error:a}),t.destroy(),a)throw a}}class g extends ce{constructor(e={}){e.cacheName=k.getPrecacheName(e.cacheName),super(e),this._fallbackToNetwork=e.fallbackToNetwork!==!1,this.plugins.push(g.copyRedirectedCacheableResponsesPlugin)}async _handle(e,t){const s=await t.cacheMatch(e);return s||(t.event&&t.event.type==="install"?await this._handleInstall(e,t):await this._handleFetch(e,t))}async _handleFetch(e,t){let s;const n=t.params||{};if(this._fallbackToNetwork){const r=n.integrity,a=e.integrity,o=!a||a===r;s=await t.fetch(new Request(e,{integrity:e.mode!=="no-cors"?a||r:void 0})),r&&o&&e.mode!=="no-cors"&&(this._useDefaultCacheabilityPluginIfNeeded(),await t.cachePut(e,s.clone()))}else throw new u("missing-precache-entry",{cacheName:this.cacheName,url:e.url});return s}async _handleInstall(e,t){this._useDefaultCacheabilityPluginIfNeeded();const s=await t.fetch(e);if(!await t.cachePut(e,s.clone()))throw new u("bad-precaching-response",{url:e.url,status:s.status});return s}_useDefaultCacheabilityPluginIfNeeded(){let e=null,t=0;for(const[s,n]of this.plugins.entries())n!==g.copyRedirectedCacheableResponsesPlugin&&(n===g.defaultPrecacheCacheabilityPlugin&&(e=s),n.cacheWillUpdate&&t++);t===0?this.plugins.push(g.defaultPrecacheCacheabilityPlugin):t>1&&e!==null&&this.plugins.splice(e,1)}}g.defaultPrecacheCacheabilityPlugin={async cacheWillUpdate({response:i}){return!i||i.status>=400?null:i}};g.copyRedirectedCacheableResponsesPlugin={async cacheWillUpdate({response:i}){return i.redirected?await te(i):i}};class he{constructor({cacheName:e,plugins:t=[],fallbackToNetwork:s=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new g({cacheName:k.getPrecacheName(e),plugins:[...t,new ae({precacheController:this})],fallbackToNetwork:s}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(e){this.addToCacheList(e),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){const t=[];for(const s of e){typeof s=="string"?t.push(s):s&&s.revision===void 0&&t.push(s.url);const{cacheKey:n,url:r}=ie(s),a=typeof s!="string"&&s.revision?"reload":"default";if(this._urlsToCacheKeys.has(r)&&this._urlsToCacheKeys.get(r)!==n)throw new u("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(r),secondEntry:n});if(typeof s!="string"&&s.integrity){if(this._cacheKeysToIntegrities.has(n)&&this._cacheKeysToIntegrities.get(n)!==s.integrity)throw new u("add-to-cache-list-conflicting-integrities",{url:r});this._cacheKeysToIntegrities.set(n,s.integrity)}if(this._urlsToCacheKeys.set(r,n),this._urlsToCacheModes.set(r,a),t.length>0){const o=`Workbox is precaching URLs without revision info: ${t.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(o)}}}install(e){return D(e,async()=>{const t=new re;this.strategy.plugins.push(t);for(const[r,a]of this._urlsToCacheKeys){const o=this._cacheKeysToIntegrities.get(a),c=this._urlsToCacheModes.get(r),l=new Request(r,{integrity:o,cache:c,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:a},request:l,event:e}))}const{updatedURLs:s,notUpdatedURLs:n}=t;return{updatedURLs:s,notUpdatedURLs:n}})}activate(e){return D(e,async()=>{const t=await self.caches.open(this.strategy.cacheName),s=await t.keys(),n=new Set(this._urlsToCacheKeys.values()),r=[];for(const a of s)n.has(a.url)||(await t.delete(a),r.push(a.url));return{deletedURLs:r}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}getIntegrityForCacheKey(e){return this._cacheKeysToIntegrities.get(e)}async matchPrecache(e){const t=e instanceof Request?e.url:e,s=this.getCacheKeyForURL(t);if(s)return(await self.caches.open(this.strategy.cacheName)).match(s)}createHandlerBoundToURL(e){const t=this.getCacheKeyForURL(e);if(!t)throw new u("non-precached-url",{url:e});return s=>(s.request=new Request(e),s.params=Object.assign({cacheKey:t},s.params),this.strategy.handle(s))}}let S;const H=()=>(S||(S=new he),S);try{self["workbox:routing:7.2.0"]&&_()}catch{}const F="GET",E=i=>i&&typeof i=="object"?i:{handle:i};class R{constructor(e,t,s=F){this.handler=E(t),this.match=e,this.method=s}setCatchHandler(e){this.catchHandler=E(e)}}class le extends R{constructor(e,t,s){const n=({url:r})=>{const a=e.exec(r.href);if(a&&!(r.origin!==location.origin&&a.index!==0))return a.slice(1)};super(n,t,s)}}class ue{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:t}=e,s=this.handleRequest({request:t,event:e});s&&e.respondWith(s)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:t}=e.data,s=Promise.all(t.urlsToCache.map(n=>{typeof n=="string"&&(n=[n]);const r=new Request(...n);return this.handleRequest({request:r,event:e})}));e.waitUntil(s),e.ports&&e.ports[0]&&s.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){const s=new URL(e.url,location.href);if(!s.protocol.startsWith("http"))return;const n=s.origin===location.origin,{params:r,route:a}=this.findMatchingRoute({event:t,request:e,sameOrigin:n,url:s});let o=a&&a.handler;const c=e.method;if(!o&&this._defaultHandlerMap.has(c)&&(o=this._defaultHandlerMap.get(c)),!o)return;let l;try{l=o.handle({url:s,request:e,event:t,params:r})}catch(h){l=Promise.reject(h)}const p=a&&a.catchHandler;return l instanceof Promise&&(this._catchHandler||p)&&(l=l.catch(async h=>{if(p)try{return await p.handle({url:s,request:e,event:t,params:r})}catch(M){M instanceof Error&&(h=M)}if(this._catchHandler)return this._catchHandler.handle({url:s,request:e,event:t});throw h})),l}findMatchingRoute({url:e,sameOrigin:t,request:s,event:n}){const r=this._routes.get(s.method)||[];for(const a of r){let o;const c=a.match({url:e,sameOrigin:t,request:s,event:n});if(c)return o=c,(Array.isArray(o)&&o.length===0||c.constructor===Object&&Object.keys(c).length===0||typeof c=="boolean")&&(o=void 0),{route:a,params:o}}return{}}setDefaultHandler(e,t=F){this._defaultHandlerMap.set(t,E(e))}setCatchHandler(e){this._catchHandler=E(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new u("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(t>-1)this._routes.get(e.method).splice(t,1);else throw new u("unregister-route-route-not-registered")}}let w;const de=()=>(w||(w=new ue,w.addFetchListener(),w.addCacheListener()),w);function fe(i,e,t){let s;if(typeof i=="string"){const r=new URL(i,location.href),a=({url:o})=>o.href===r.href;s=new R(a,e,t)}else if(i instanceof RegExp)s=new le(i,e,t);else if(typeof i=="function")s=new R(i,e,t);else if(i instanceof R)s=i;else throw new u("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return de().registerRoute(s),s}function ge(i,e=[]){for(const t of[...i.searchParams.keys()])e.some(s=>s.test(t))&&i.searchParams.delete(t);return i}function*pe(i,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:t="index.html",cleanURLs:s=!0,urlManipulation:n}={}){const r=new URL(i,location.href);r.hash="",yield r.href;const a=ge(r,e);if(yield a.href,t&&a.pathname.endsWith("/")){const o=new URL(a.href);o.pathname+=t,yield o.href}if(s){const o=new URL(a.href);o.pathname+=".html",yield o.href}if(n){const o=n({url:r});for(const c of o)yield c.href}}class ye extends R{constructor(e,t){const s=({request:n})=>{const r=e.getURLsToCacheKeys();for(const a of pe(n.url,t)){const o=r.get(a);if(o){const c=e.getIntegrityForCacheKey(o);return{cacheKey:o,integrity:c}}}};super(s,e.strategy)}}function we(i){const e=H(),t=new ye(e,i);fe(t)}const me="-precache-",xe=async(i,e=me)=>{const s=(await self.caches.keys()).filter(n=>n.includes(e)&&n.includes(self.registration.scope)&&n!==i);return await Promise.all(s.map(n=>self.caches.delete(n))),s};function Re(){self.addEventListener("activate",i=>{const e=k.getPrecacheName();i.waitUntil(xe(e).then(t=>{}))})}function Ue(i){H().precache(i)}function _e(i,e){Ue(i),we(e)}new TextEncoder;const Ce=4096;function O(i,e,t){let s=e;const n=s+t,r=[];let a="";for(;s<n;){const o=i[s++];if((o&128)===0)r.push(o);else if((o&224)===192){const c=i[s++]&63;r.push((o&31)<<6|c)}else if((o&240)===224){const c=i[s++]&63,l=i[s++]&63;r.push((o&31)<<12|c<<6|l)}else if((o&248)===240){const c=i[s++]&63,l=i[s++]&63,p=i[s++]&63;let h=(o&7)<<18|c<<12|l<<6|p;h>65535&&(h-=65536,r.push(h>>>10&1023|55296),h=56320|h&1023),r.push(h)}else r.push(o);r.length>=Ce&&(a+=String.fromCharCode(...r),r.length=0)}return r.length>0&&(a+=String.fromCharCode(...r)),a}const be=new TextDecoder,Ee=200;function ke(i,e,t){const s=i.subarray(e,e+t);return be.decode(s)}function Le(i,e,t){return t>Ee?ke(i,e,t):O(i,e,t)}class b{constructor(e,t){this.type=e,this.data=t}}class d extends Error{constructor(e){super(e);const t=Object.create(d.prototype);Object.setPrototypeOf(this,t),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:d.name})}}const m=4294967295;function Se(i,e,t){const s=Math.floor(t/4294967296),n=t;i.setUint32(e,s),i.setUint32(e+4,n)}function W(i,e){const t=i.getInt32(e),s=i.getUint32(e+4);return t*4294967296+s}function Ae(i,e){const t=i.getUint32(e),s=i.getUint32(e+4);return t*4294967296+s}const Te=-1,ve=4294967296-1,Pe=17179869184-1;function Ie({sec:i,nsec:e}){if(i>=0&&e>=0&&i<=Pe)if(e===0&&i<=ve){const t=new Uint8Array(4);return new DataView(t.buffer).setUint32(0,i),t}else{const t=i/4294967296,s=i&4294967295,n=new Uint8Array(8),r=new DataView(n.buffer);return r.setUint32(0,e<<2|t&3),r.setUint32(4,s),n}else{const t=new Uint8Array(12),s=new DataView(t.buffer);return s.setUint32(0,e),Se(s,4,i),t}}function Me(i){const e=i.getTime(),t=Math.floor(e/1e3),s=(e-t*1e3)*1e6,n=Math.floor(s/1e9);return{sec:t+n,nsec:s-n*1e9}}function Be(i){if(i instanceof Date){const e=Me(i);return Ie(e)}else return null}function De(i){const e=new DataView(i.buffer,i.byteOffset,i.byteLength);switch(i.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:{const t=e.getUint32(0),s=e.getUint32(4),n=(t&3)*4294967296+s,r=t>>>2;return{sec:n,nsec:r}}case 12:{const t=W(e,4),s=e.getUint32(0);return{sec:t,nsec:s}}default:throw new d(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${i.length}`)}}function Ke(i){const e=De(i);return new Date(e.sec*1e3+e.nsec/1e6)}const Ne={type:Te,encode:Be,decode:Ke};class T{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(Ne)}register({type:e,encode:t,decode:s}){if(e>=0)this.encoders[e]=t,this.decoders[e]=s;else{const n=-1-e;this.builtInEncoders[n]=t,this.builtInDecoders[n]=s}}tryToEncode(e,t){for(let s=0;s<this.builtInEncoders.length;s++){const n=this.builtInEncoders[s];if(n!=null){const r=n(e,t);if(r!=null){const a=-1-s;return new b(a,r)}}}for(let s=0;s<this.encoders.length;s++){const n=this.encoders[s];if(n!=null){const r=n(e,t);if(r!=null){const a=s;return new b(a,r)}}}return e instanceof b?e:null}decode(e,t,s){const n=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return n?n(e,t,s):new b(t,e)}}T.defaultCodec=new T;function He(i){return i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer}function K(i){return i instanceof Uint8Array?i:ArrayBuffer.isView(i)?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):He(i)?new Uint8Array(i):Uint8Array.from(i)}function A(i){return`${i<0?"-":""}0x${Math.abs(i).toString(16).padStart(2,"0")}`}const Fe=16,Oe=16;class We{constructor(e=Fe,t=Oe){this.hit=0,this.miss=0,this.maxKeyLength=e,this.maxLengthPerKey=t,this.caches=[];for(let s=0;s<this.maxKeyLength;s++)this.caches.push([])}canBeCached(e){return e>0&&e<=this.maxKeyLength}find(e,t,s){const n=this.caches[s-1];e:for(const r of n){const a=r.bytes;for(let o=0;o<s;o++)if(a[o]!==e[t+o])continue e;return r.str}return null}store(e,t){const s=this.caches[e.length-1],n={bytes:e,str:t};s.length>=this.maxLengthPerKey?s[Math.random()*s.length|0]=n:s.push(n)}decode(e,t,s){const n=this.find(e,t,s);if(n!=null)return this.hit++,n;this.miss++;const r=O(e,t,s),a=Uint8Array.prototype.slice.call(e,t,t+s);return this.store(a,r),r}}const v="array",U="map_key",$="map_value",$e=i=>{if(typeof i=="string"||typeof i=="number")return i;throw new d("The type of key must be string or number but "+typeof i)};class je{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(e){const t=this.getUninitializedStateFromPool();t.type=v,t.position=0,t.size=e,t.array=new Array(e)}pushMapState(e){const t=this.getUninitializedStateFromPool();t.type=U,t.readCount=0,t.size=e,t.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const e={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(e)}return this.stack[this.stackHeadPosition]}release(e){if(this.stack[this.stackHeadPosition]!==e)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(e.type===v){const s=e;s.size=0,s.array=void 0,s.position=0,s.type=void 0}if(e.type===U||e.type===$){const s=e;s.size=0,s.map=void 0,s.readCount=0,s.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}const x=-1,P=new DataView(new ArrayBuffer(0)),qe=new Uint8Array(P.buffer);try{P.getInt8(0)}catch(i){if(!(i instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}const N=new RangeError("Insufficient data"),ze=new We;class I{constructor(e){this.totalPos=0,this.pos=0,this.view=P,this.bytes=qe,this.headByte=x,this.stack=new je,this.entered=!1,this.extensionCodec=e?.extensionCodec??T.defaultCodec,this.context=e?.context,this.useBigInt64=e?.useBigInt64??!1,this.rawStrings=e?.rawStrings??!1,this.maxStrLength=e?.maxStrLength??m,this.maxBinLength=e?.maxBinLength??m,this.maxArrayLength=e?.maxArrayLength??m,this.maxMapLength=e?.maxMapLength??m,this.maxExtLength=e?.maxExtLength??m,this.keyDecoder=e?.keyDecoder!==void 0?e.keyDecoder:ze,this.mapKeyConverter=e?.mapKeyConverter??$e}clone(){return new I({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=x,this.stack.reset()}setBuffer(e){const t=K(e);this.bytes=t,this.view=new DataView(t.buffer,t.byteOffset,t.byteLength),this.pos=0}appendBuffer(e){if(this.headByte===x&&!this.hasRemaining(1))this.setBuffer(e);else{const t=this.bytes.subarray(this.pos),s=K(e),n=new Uint8Array(t.length+s.length);n.set(t),n.set(s,t.length),this.setBuffer(n)}}hasRemaining(e){return this.view.byteLength-this.pos>=e}createExtraByteError(e){const{view:t,pos:s}=this;return new RangeError(`Extra ${t.byteLength-s} of ${t.byteLength} byte(s) found at buffer[${e}]`)}decode(e){if(this.entered)return this.clone().decode(e);try{this.entered=!0,this.reinitializeState(),this.setBuffer(e);const t=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return t}finally{this.entered=!1}}*decodeMulti(e){if(this.entered){yield*this.clone().decodeMulti(e);return}try{for(this.entered=!0,this.reinitializeState(),this.setBuffer(e);this.hasRemaining(1);)yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(e){if(this.entered)return this.clone().decodeAsync(e);try{this.entered=!0;let t=!1,s;for await(const o of e){if(t)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(o);try{s=this.doDecodeSync(),t=!0}catch(c){if(!(c instanceof RangeError))throw c}this.totalPos+=this.pos}if(t){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return s}const{headByte:n,pos:r,totalPos:a}=this;throw new RangeError(`Insufficient data in parsing ${A(n)} at ${a} (${r} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(e){return this.decodeMultiAsync(e,!0)}decodeStream(e){return this.decodeMultiAsync(e,!1)}async*decodeMultiAsync(e,t){if(this.entered){yield*this.clone().decodeMultiAsync(e,t);return}try{this.entered=!0;let s=t,n=-1;for await(const r of e){if(t&&n===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(r),s&&(n=this.readArraySize(),s=!1,this.complete());try{for(;yield this.doDecodeSync(),--n!==0;);}catch(a){if(!(a instanceof RangeError))throw a}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){e:for(;;){const e=this.readHeadByte();let t;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){const n=e-128;if(n!==0){this.pushMapState(n),this.complete();continue e}else t={}}else if(e<160){const n=e-144;if(n!==0){this.pushArrayState(n),this.complete();continue e}else t=[]}else{const n=e-160;t=this.decodeString(n,0)}else if(e===192)t=null;else if(e===194)t=!1;else if(e===195)t=!0;else if(e===202)t=this.readF32();else if(e===203)t=this.readF64();else if(e===204)t=this.readU8();else if(e===205)t=this.readU16();else if(e===206)t=this.readU32();else if(e===207)this.useBigInt64?t=this.readU64AsBigInt():t=this.readU64();else if(e===208)t=this.readI8();else if(e===209)t=this.readI16();else if(e===210)t=this.readI32();else if(e===211)this.useBigInt64?t=this.readI64AsBigInt():t=this.readI64();else if(e===217){const n=this.lookU8();t=this.decodeString(n,1)}else if(e===218){const n=this.lookU16();t=this.decodeString(n,2)}else if(e===219){const n=this.lookU32();t=this.decodeString(n,4)}else if(e===220){const n=this.readU16();if(n!==0){this.pushArrayState(n),this.complete();continue e}else t=[]}else if(e===221){const n=this.readU32();if(n!==0){this.pushArrayState(n),this.complete();continue e}else t=[]}else if(e===222){const n=this.readU16();if(n!==0){this.pushMapState(n),this.complete();continue e}else t={}}else if(e===223){const n=this.readU32();if(n!==0){this.pushMapState(n),this.complete();continue e}else t={}}else if(e===196){const n=this.lookU8();t=this.decodeBinary(n,1)}else if(e===197){const n=this.lookU16();t=this.decodeBinary(n,2)}else if(e===198){const n=this.lookU32();t=this.decodeBinary(n,4)}else if(e===212)t=this.decodeExtension(1,0);else if(e===213)t=this.decodeExtension(2,0);else if(e===214)t=this.decodeExtension(4,0);else if(e===215)t=this.decodeExtension(8,0);else if(e===216)t=this.decodeExtension(16,0);else if(e===199){const n=this.lookU8();t=this.decodeExtension(n,1)}else if(e===200){const n=this.lookU16();t=this.decodeExtension(n,2)}else if(e===201){const n=this.lookU32();t=this.decodeExtension(n,4)}else throw new d(`Unrecognized type byte: ${A(e)}`);this.complete();const s=this.stack;for(;s.length>0;){const n=s.top();if(n.type===v)if(n.array[n.position]=t,n.position++,n.position===n.size)t=n.array,s.release(n);else continue e;else if(n.type===U){if(t==="__proto__")throw new d("The key __proto__ is not allowed");n.key=this.mapKeyConverter(t),n.type=$;continue e}else if(n.map[n.key]=t,n.readCount++,n.readCount===n.size)t=n.map,s.release(n);else{n.key=null,n.type=U;continue e}}return t}}readHeadByte(){return this.headByte===x&&(this.headByte=this.readU8()),this.headByte}complete(){this.headByte=x}readArraySize(){const e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:{if(e<160)return e-144;throw new d(`Unrecognized array type byte: ${A(e)}`)}}}pushMapState(e){if(e>this.maxMapLength)throw new d(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(e)}pushArrayState(e){if(e>this.maxArrayLength)throw new d(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(e)}decodeString(e,t){return!this.rawStrings||this.stateIsMapKey()?this.decodeUtf8String(e,t):this.decodeBinary(e,t)}decodeUtf8String(e,t){if(e>this.maxStrLength)throw new d(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+t+e)throw N;const s=this.pos+t;let n;return this.stateIsMapKey()&&this.keyDecoder?.canBeCached(e)?n=this.keyDecoder.decode(this.bytes,s,e):n=Le(this.bytes,s,e),this.pos+=t+e,n}stateIsMapKey(){return this.stack.length>0?this.stack.top().type===U:!1}decodeBinary(e,t){if(e>this.maxBinLength)throw new d(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(e+t))throw N;const s=this.pos+t,n=this.bytes.subarray(s,s+e);return this.pos+=t+e,n}decodeExtension(e,t){if(e>this.maxExtLength)throw new d(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);const s=this.view.getInt8(this.pos+t),n=this.decodeBinary(e,t+1);return this.extensionCodec.decode(n,s,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const e=this.view.getUint8(this.pos);return this.pos++,e}readI8(){const e=this.view.getInt8(this.pos);return this.pos++,e}readU16(){const e=this.view.getUint16(this.pos);return this.pos+=2,e}readI16(){const e=this.view.getInt16(this.pos);return this.pos+=2,e}readU32(){const e=this.view.getUint32(this.pos);return this.pos+=4,e}readI32(){const e=this.view.getInt32(this.pos);return this.pos+=4,e}readU64(){const e=Ae(this.view,this.pos);return this.pos+=8,e}readI64(){const e=W(this.view,this.pos);return this.pos+=8,e}readU64AsBigInt(){const e=this.view.getBigUint64(this.pos);return this.pos+=8,e}readI64AsBigInt(){const e=this.view.getBigInt64(this.pos);return this.pos+=8,e}readF32(){const e=this.view.getFloat32(this.pos);return this.pos+=4,e}readF64(){const e=this.view.getFloat64(this.pos);return this.pos+=8,e}}function Ve(i,e){return new I(e).decode(i)}self.skipWaiting();se();const j=[{"revision":null,"url":"assets/appconfig-C7OMKUmA.js"},{"revision":null,"url":"assets/axios-DG58Vhjo.js"},{"revision":null,"url":"assets/ErrorNotFound-LX1L_GYg.js"},{"revision":null,"url":"assets/i18n-AtHMD_BR.js"},{"revision":null,"url":"assets/index-C2PgjmK5.css"},{"revision":null,"url":"assets/index-Tz2Q-aOQ.js"},{"revision":"db941c4742278975b9763eecdcc3f794","url":"index.html"},{"revision":"17792cb4edf7d4ac5537a20baad8fd7e","url":"icons/icon-192x192.png"},{"revision":"9aab57a5c757d319f5c5ec54f2660b9c","url":"icons/icon-512x512.png"},{"revision":"242e7f9f7a35e0b1ca85f6471beca289","url":"manifest.webmanifest"}];console.log("Dans SW");console.log("WB_MANIFEST >>>>>>>");j.forEach(i=>{console.log("WB_MANIFEST: "+i.url)});console.log("WB_MANIFEST <<<<<<<");console.log("precacheAndRoute"),_e(j);Re();const Ye=i=>{const e="=".repeat((4-i.length%4)%4),t=(i+e).replace(/\-/g,"+").replace(/_/g,"/"),s=atob(t),n=new Uint8Array(s.length);for(let r=0;r<s.length;++r)n[r]=s.charCodeAt(r);return n},Xe=new BroadcastChannel("channel-pubsub");self.addEventListener("push",i=>{const e=i.data?i.data.text():null;let t;try{t=e?Ve(Ye(e)):{}}catch(s){console.log("msgPush: "+s.toString())}t&&(t.sw?console.log("Futur traitement:"+(t?JSON.stringify(t):"???")):Xe.postMessage(t))});self.addEventListener("message",i=>{i.data&&i.data.type==="FROM_APP"&&console.log("Appel depuis app:"+JSON.stringify(i.data.payload))});
